// Code generated by metactl. DO NOT EDIT.
// source: player.proto

package meta

import (
	"errors"

	sess "github.com/jageros/hawox/example/mygame/protos/meta/sess"

	pb "github.com/jageros/hawox/example/mygame/protos/pb"	
)

//@ C2S_FETCH_CONFIG resp: Config
//------------------------------------------------------------------------------------------

var C2S_FETCH_CONFIG = &meta_C2S_FETCH_CONFIG{}

// implement IMeta

type meta_C2S_FETCH_CONFIG struct {
	handle func(ss sess.ISession) (resp *pb.Config, err error)
}

func (m *meta_C2S_FETCH_CONFIG) RegistryHandle(f func(ss sess.ISession) (resp *pb.Config, err error)) {
	m.handle = f
}

func (m *meta_C2S_FETCH_CONFIG) Handle(ss sess.ISession, arg interface{}) (interface{}, error) {
	return m.handle(ss)
}

func (m *meta_C2S_FETCH_CONFIG) GetMsgID() pb.MsgID {
	return pb.MsgID_C2S_FETCH_CONFIG
}

func (m *meta_C2S_FETCH_CONFIG) EncodeArg(arg interface{}) ([]byte, error) {
		return nil, nil
}

func (m *meta_C2S_FETCH_CONFIG) DecodeArg(data []byte) (interface{}, error) {
	return nil, nil
}

func (m *meta_C2S_FETCH_CONFIG) EncodeReply(reply interface{}) ([]byte, error) {
	_reply, ok := reply.(*pb.Config)
	if !ok {
		p, ok := reply.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("C2S_FETCH_CONFIG_meta EncodeReply error type")
	}

	return _reply.Marshal()
}

func (m *meta_C2S_FETCH_CONFIG) DecodeReply(data []byte) (interface{}, error) {
	reply := &pb.Config{}
	if err := reply.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return reply, nil
	}
}

// ================== C2S_FETCH_CONFIG End ==================


//@ C2S_PLAYER_LOGIN req: LoginArg resp: LoginResp
//------------------------------------------------------------------------------------------

var C2S_PLAYER_LOGIN = &meta_C2S_PLAYER_LOGIN{}

// implement IMeta

type meta_C2S_PLAYER_LOGIN struct {
	handle func(ss sess.ISession, arg *pb.LoginArg) (resp *pb.LoginResp, err error)
}

func (m *meta_C2S_PLAYER_LOGIN) RegistryHandle(f func(ss sess.ISession, arg *pb.LoginArg) (resp *pb.LoginResp, err error)) {
	m.handle = f
}

func (m *meta_C2S_PLAYER_LOGIN) Handle(ss sess.ISession, arg interface{}) (interface{}, error) {
	return m.handle(ss, arg.(*pb.LoginArg))
}

func (m *meta_C2S_PLAYER_LOGIN) GetMsgID() pb.MsgID {
	return pb.MsgID_C2S_PLAYER_LOGIN
}

func (m *meta_C2S_PLAYER_LOGIN) EncodeArg(arg interface{}) ([]byte, error) {
	_arg, ok := arg.(*pb.LoginArg)
	if !ok {
		p, ok := arg.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("C2S_PLAYER_LOGIN_meta EncodeArg error type")
	}

	return _arg.Marshal()
}

func (m *meta_C2S_PLAYER_LOGIN) DecodeArg(data []byte) (interface{}, error) {
	arg := &pb.LoginArg{}
	if err := arg.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return arg, nil
	}
}

func (m *meta_C2S_PLAYER_LOGIN) EncodeReply(reply interface{}) ([]byte, error) {
	_reply, ok := reply.(*pb.LoginResp)
	if !ok {
		p, ok := reply.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("C2S_PLAYER_LOGIN_meta EncodeReply error type")
	}

	return _reply.Marshal()
}

func (m *meta_C2S_PLAYER_LOGIN) DecodeReply(data []byte) (interface{}, error) {
	reply := &pb.LoginResp{}
	if err := reply.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return reply, nil
	}
}

// ================== C2S_PLAYER_LOGIN End ==================


//@ C2S_PLAYER_PLAYING req: PlayingArg
//------------------------------------------------------------------------------------------

var C2S_PLAYER_PLAYING = &meta_C2S_PLAYER_PLAYING{}

// implement IMeta

type meta_C2S_PLAYER_PLAYING struct {
	handle func(ss sess.ISession, arg *pb.PlayingArg) (err error)
}

func (m *meta_C2S_PLAYER_PLAYING) RegistryHandle(f func(ss sess.ISession, arg *pb.PlayingArg) (err error)) {
	m.handle = f
}

func (m *meta_C2S_PLAYER_PLAYING) Handle(ss sess.ISession, arg interface{}) (interface{}, error) {
	return nil, m.handle(ss, arg.(*pb.PlayingArg))
}

func (m *meta_C2S_PLAYER_PLAYING) GetMsgID() pb.MsgID {
	return pb.MsgID_C2S_PLAYER_PLAYING
}

func (m *meta_C2S_PLAYER_PLAYING) EncodeArg(arg interface{}) ([]byte, error) {
	_arg, ok := arg.(*pb.PlayingArg)
	if !ok {
		p, ok := arg.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("C2S_PLAYER_PLAYING_meta EncodeArg error type")
	}

	return _arg.Marshal()
}

func (m *meta_C2S_PLAYER_PLAYING) DecodeArg(data []byte) (interface{}, error) {
	arg := &pb.PlayingArg{}
	if err := arg.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return arg, nil
	}
}

func (m *meta_C2S_PLAYER_PLAYING) EncodeReply(reply interface{}) ([]byte, error) {
	return nil, nil
}

func (m *meta_C2S_PLAYER_PLAYING) DecodeReply(data []byte) (interface{}, error) {
	return nil, nil
}

// ================== C2S_PLAYER_PLAYING End ==================


//@ C2S_PLAYER_LOGOUT
//------------------------------------------------------------------------------------------

var C2S_PLAYER_LOGOUT = &meta_C2S_PLAYER_LOGOUT{}

// implement IMeta

type meta_C2S_PLAYER_LOGOUT struct {
	handle func(ss sess.ISession) (err error)
}

func (m *meta_C2S_PLAYER_LOGOUT) RegistryHandle(f func(ss sess.ISession) (err error)) {
	m.handle = f
}

func (m *meta_C2S_PLAYER_LOGOUT) Handle(ss sess.ISession, arg interface{}) (interface{}, error) {
	return nil, m.handle(ss)
}

func (m *meta_C2S_PLAYER_LOGOUT) GetMsgID() pb.MsgID {
	return pb.MsgID_C2S_PLAYER_LOGOUT
}

func (m *meta_C2S_PLAYER_LOGOUT) EncodeArg(arg interface{}) ([]byte, error) {
		return nil, nil
}

func (m *meta_C2S_PLAYER_LOGOUT) DecodeArg(data []byte) (interface{}, error) {
	return nil, nil
}

func (m *meta_C2S_PLAYER_LOGOUT) EncodeReply(reply interface{}) ([]byte, error) {
	return nil, nil
}

func (m *meta_C2S_PLAYER_LOGOUT) DecodeReply(data []byte) (interface{}, error) {
	return nil, nil
}

// ================== C2S_PLAYER_LOGOUT End ==================

