/**
 * @Author:  jager
 * @Email:   lhj168os@gmail.com
 * @File:    meta
 * @Date:    2022/3/8 5:38 下午
 * @package: template
 * @Version: v1.0.0
 *
 * @Description:
 *
 */

package metatemp

import (
	"errors"
	"fmt"
	"strings"
)

func Head(pkg string) string {
	head := `// Generated by gen_meta.py
// DO NOT EDIT!

package meta

import (
	"errors"

	pb "%s"	
)
`
	return fmt.Sprintf(head, pkg)
}

func MetaStruct(note, enum, msgId string) string {
	metaStruct := `
%s
//------------------------------------------------------------------------------------------
// implement IMeta

type %s_Meta struct {
}

func (m *%s_Meta) GetMsgID() pb.%s {
	return pb.%s_%s
}
`
	return fmt.Sprintf(metaStruct, note, msgId, msgId, enum, enum, msgId)
}

func EncodeArg(msgId, req string) string {
	if req == "nil" || req == "" || req == "null" {
		return fmt.Sprintf(`
func (m *%s_Meta) EncodeArg(arg interface{}) ([]byte, error) {
		return nil, nil
}
`, msgId)
	}

	return fmt.Sprintf(`
func (m *%s_Meta) EncodeArg(arg interface{}) ([]byte, error) {
	_arg, ok := arg.(*pb.%s)
	if !ok {
		p, ok := arg.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("%s_Meta EncodeArg error type")
	}

	return _arg.Marshal()
}
`, msgId, req, msgId)
}

func DecodeArg(msgId, req string) string {
	if req == "nil" || req == "" || req == "null" {
		return fmt.Sprintf(`
func (m *%s_Meta) DecodeArg(data []byte) (interface{}, error) {
	return nil, nil
}
`, msgId)
	}

	return fmt.Sprintf(`
func (m *%s_Meta) DecodeArg(data []byte) (interface{}, error) {
	arg := &pb.%s{}
	if err := arg.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return arg, nil
	}
}
`, msgId, req)
}

func EncodeReply(msgId, resp string) string {
	if resp == "" || resp == "nil" || resp == "null" || resp == "ok" {
		return fmt.Sprintf(`
func (m *%s_Meta) EncodeReply(reply interface{}) ([]byte, error) {
	return nil, nil
}
`, msgId)
	}
	return fmt.Sprintf(`
func (m *%s_Meta) EncodeReply(reply interface{}) ([]byte, error) {
	_reply, ok := reply.(*pb.%s)
	if !ok {
		p, ok := reply.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("%s_Meta EncodeReply error type")
	}

	return _reply.Marshal()
}
`, msgId, resp, msgId)
}

func DecodeReply(msgId, resp string) string {
	if resp == "" || resp == "nil" || resp == "null" || resp == "ok" {
		return fmt.Sprintf(`
func (m *%s_Meta) DecodeReply(data []byte) (interface{}, error) {
	return nil, nil
}
`, msgId)
	}

	return fmt.Sprintf(`
func (m *%s_Meta) DecodeReply(data []byte) (interface{}, error) {
	reply := &pb.%s{}
	if err := reply.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return reply, nil
	}
}
`, msgId, resp)
}

func End(msgId string) string {
	return fmt.Sprintf("\n// ================== %s End ==================\n\n", msgId)
}

func GenMeta(enumName, notes, msgid, req, resp string) string {
	code := MetaStruct(notes, enumName, msgid)
	code += EncodeArg(msgid, req)
	code += DecodeArg(msgid, req)
	code += EncodeReply(msgid, resp)
	code += DecodeReply(msgid, resp)
	code += End(msgid)
	return code
}

func splitByExtraSpace(str string) []string {
	str = strings.Replace(str, "\t", " ", -1)
	ss := strings.Split(str, " ")
	var sss []string
	for _, s := range ss {
		if s != "" {
			sss = append(sss, s)
		}
	}
	return sss
}

func GenMetaFile(pkgName, enumName string, rpcInfos []string) (string, []string, error) {
	if len(rpcInfos) <= 0 {
		return "", nil, errors.New("not has rpc info")
	}
	result := Head(pkgName)
	var allMsgId []string
	for _, ri := range rpcInfos {
		if strings.Contains(ri, "//@") {
			strs := splitByExtraSpace(ri)
			var msgid, req, resp string
			for i := 0; i+1 < len(strs); i += 2 {
				switch strs[i] {
				case "//@":
					msgid = strs[i+1]
				case "req:":
					if strs[i] != "resp:" && !strings.HasPrefix(strs[i], "//") {
						req = strs[i+1]
					}
				case "resp:":
					if strs[i] != "req:" && !strings.HasPrefix(strs[i], "//") {
						resp = strs[i+1]
					}
				}
			}
			note := strings.Join(strs, " ")
			result += GenMeta(enumName, note, msgid, req, resp)
			allMsgId = append(allMsgId, msgid)
		}
	}
	if len(allMsgId) <= 0 {
		return "", nil, errors.New("not has right rpc info")
	}
	return result, allMsgId, nil
}

func GenMetaRegister(msgids []string) string {
	code := `// Generated by gen_meta.py
// DO NOT EDIT!

package meta

func init()  {
`

	for _, msgid := range msgids {
		code += fmt.Sprintf("	registerMeta(&%s_Meta{})\n", msgid)
	}

	code += "}"
	return code
}
